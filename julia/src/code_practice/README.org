* Perdiendo el miedo a programar

Programar es una habilidad que necesita /pr√°ctica/ es casi imposible ser diestro
programando si no se ejercita el expresar las ideas mediante un lenguaje de
programaci√≥n, el objetivo de esta secci√≥n (y las sesiones correspodientes) es el
poner en pr√°ctica esa habilidad para generar las conexiones sin√°pticas que nos
permitir√°n a expresar los pensamientos en forma de c√≥digo (cosa que cualquier
persona puede aprender).


** ¬øDe qu√© trata esto?

La idea general es implementar todos y cada uno de los ejercicios establecidos
en el libro =Julia Data Science= de los autores Jose Stropoli, Rik Huijzer y
L√°zaro Alonso, este libro es un libro licenciado bajo Creative Commons por lo
que podemos modificarlo, utilizarlo y distribuirlo bajo la misma licencia.

Podemos bajar el libro (y todo el c√≥digo fuente) desde su cuenta oficial de
[[https://github.com/JuliaDataScience/JuliaDataScience/tree/main][github]]. Aunque el c√≥digo est√° en el repositorio inicial la idea es que nos
"ensuciemos" las manos y escribamos dicho c√≥digo.

El objetivo del libro es darnos las herramientas necesarias para sentirnos
c√≥modos analizando datos utilizando =julia= como una herramienta para dichos
an√°lizis (Ver apartado "[[https://juliadatascience.io/why_data_science][what's Data Science?]]" del libro).

* ¬øPor qu√© Julia?
** Julia para los no programadores
La ciencia de datos te ha cautivado, despertando tu inter√©s por aprender de qu√©
se trata y c√≥mo puedes usarla para construir tu carrera en el √°mbito acad√©mico o
en la industria. Entonces, intentas encontrar recursos para aprender este nuevo
oficio y te encuentras con un mundo de acr√≥nimos complejos: =pandas=, =dplyr=,
=data.table=, =numpy=, =matplotlib=, =ggplot2=, =bokeh=, y la lista sigue y sigue.

De repente escuchas un nombre: "Julia". ¬øQu√© es esto? ¬øEn qu√© se diferencia de
otras herramientas que la gente te recomienda para la ciencia de datos?

¬øPor qu√© deber√≠as dedicar tu valioso tiempo a aprender un lenguaje que casi
nunca se menciona en las ofertas de trabajo, posiciones en laboratorios, puestos
de posdoctorado o descripciones de trabajos acad√©micos? La respuesta es que
Julia es un enfoque novedoso tanto para la programaci√≥n como para la ciencia de
datos. Todo lo que haces en Python o en R, puedes hacerlo en Julia con la
ventaja de escribir un c√≥digo legible, r√°pido y poderoso. Por lo tanto, el
lenguaje Julia est√° ganando popularidad, y por buenas razones.

As√≠ que, si no tienes ning√∫n conocimiento previo en programaci√≥n, te animamos
mucho a que tomes Julia como tu primer lenguaje de programaci√≥n y marco de
trabajo en ciencia de datos.
** Julia para los programadores

1. La sint√°xis de Julia es muy sencilla, por lo que traducir tus programas
   escritos en =r= y =python= puede hacerse en minutos.
2. Julia es un lenguaje enfocado en el desempe√±o y te da herramientas para
   ajustar tus programas con el fin de que puedas correr m√°s r√°pido tu c√≥digo.

   De hecho Julia es parte del [[https://www.hpcwire.com/off-the-wire/julia-joins-petaflop-club/][petaflop club]].
3. Cuando tu c√≥digo necesita un ajuste serio y est√°s utilizando =r= o =python=
   necesitas migrar a otros lenguajes como =fortran=, =c= o =c++= para escribir
   funciones especializadas que ejecuten el c√≥digo "lento", en Julia s√≥lo tienes
   que verificar el c√≥digo escrito en Julia.
4. Julia posee un administrador de paquetes que te permite utilizar c√≥digo de
   bibliotecas sin tanta fricci√≥n, adem√°s te permite crear tus propias
   bibliotecas para compartirlas con el mundo.
5. Julia posee herramientas de administraci√≥n de proyectos que nos permite
   colaborar en un proyecto con m√∫ltiples personas sin morir en el intento (o
   estar peleando con otros desarrolladores porque "rompen" el c√≥digo).

** ¬øCu√°l es el objetivo de Julia?

En resumen: ser un lenguaje sencillo de aprender y utilizar (como =python= y =r=)
pero r√°pido y √∫til para aplicaciones cr√≠ticas que requieran un c√≥mputo
especializado (como =c=, =c++= y =fortran=) ¬øC√≥mo se logra esto? Los creadores del
lenguaje utilizaron una t√©cnica de compilaci√≥n y parseo llamada =LLVM= (que es un
est√°ndar) todo el c√≥digo escrito en Julia se transforma a instrucciones LLVM
(que son de bajo nivel, pero sin llegar a ser ensamblador), dichas instrucciones
pueden ser le√≠das por cualquier computadora (cpu) que tenga implementado LLVM,
haciendo que el c√≥digo sea portable (no tenemos que reescribir nuestros
programas de Julia para distintas arquitecturas de c√≥mputo) y que sea eficiente
(las instrucciones LLVM se traducen f√°cilmente a ensamblador)

Podemos tomar como ejemplo las siguientes funciones:

#+begin_src julia
  mas_tres(x) = x + 3
  funcion(x) = mas_tres(2 * x)
#+end_src

Al ejecutar =funcion(3)= obtenemos el valor =9=. Si tuvi√©ramos que indicarle a una
computadora paso por paso las instrucciones que necesita ejecutar para que el
c√≥digo de arriba sea correcto deber√≠amos de indicar lo siguiente:

1. Calcula el resultado de la operaci√≥n =2*3=.
2. Pasa el resultado de la operaci√≥n anterior a como argumento a la funci√≥n
   =mas_tres=.
3. Calcula la operaci√≥n =2 + argumento de la funci√≥n mas_tres=.

Podemos preguntarle a Julia que nos muestre el c√≥digo que genera utilizando la
opci√≥n =@code_typed= de la siguiente forma dentro del int√©rprete de Julia:

#+begin_src julia
  mas_tres(x) = x + 3
  funcion(x) = mas_tres(2 * x)
  @code_llvm debuginfo=:none funcion(3)
#+end_src

Lo cual nos regresa lo siguiente:

#+begin_src julia
  ; Function Signature: funcion(Int64)
  define i64 @julia_funcion_944(i64 signext %"x::Int64") #0 {
  top:
    %0 = shl i64 %"x::Int64", 1
    %1 = add i64 %0, 3
    ret i64 %1
  }
#+end_src

El programa generado por Julia (mandar a llamar a la funci√≥n =funcion(3)=) dice lo
siguiente:

1. Toma el argumento de la funci√≥n y su valor, ahora ve la representaci√≥n en
   binario de dicho n√∫mero (bits) y desplaza el bit m√°s peque√±o a la izquierda.
   La operaci√≥n de desplazamiento a la izquierda de un bit es equivalente a
   multiplicar por 2. =tarea moral: ¬øPor qu√© pasa esto?=
2. S√∫male 3 al resultado anterior.

Por debajo Julia elimina la llamada a =mas_tres= porque tiene t√©cnicas de
optimizaci√≥n de c√≥digo de √∫ltima generaci√≥n (de hecho julia es un lenguaje
"compilado" pero que tiene un int√©rprete gracias a los avances te√≥ricos en
t√©cnicas de compilaci√≥n e int√©rpretes de lenguajes de programaci√≥n).

* Introducci√≥n a la programaci√≥n en Julia

Antes que nada la √∫ltima palabra la tiene la [[https://docs.julialang.org/][documentaci√≥n oficial]] de Julia, no
hay mejor recurso para saber c√≥mo funciona el lenguaje o una biblioteca que la
documentaci√≥n oficial. Esta sesi√≥n *no* te har√° un experto en Julia, s√≥lo nos
ayudar√° a "perder el miedo" para entender c√≥mo tirar c√≥digo usando la
herramienta.

** Ambientes de ejecuci√≥n

Antes de comenzar con la sint√°xis del lenguaje necesitamos saber c√≥mo ejecutar
c√≥digo, la forma m√°s f√°cil de ejecutar c√≥digo es a trav√©s de una herramienta
llamada =repl=, la cual leer√° el c√≥digo (linea por l√≠nea) que le escribamos y nos
responder√° interactivamente evaluando ese c√≥digo que le dimos.

Para ejecutar la =repl= de julia basta con ejecutar el comando =juia= dentro de
nuestra l√≠nea de comandos (o =julia.exe= si est√°s en windows). La =rep= se comporta de la siguiente manera:

#+begin_src julia
  julia> x = 2
  2

  julia> x + 1
  3
#+end_src

Esta forma de evaluar c√≥digo funciona muy bien para cosas sencillas, pero ¬øqu√©
pasa si queremos guardar el c√≥digo que metimos dentro de la sesi√≥n? o ¬øc√≥mo
compartimos el c√≥digo que acabamos de ejecutar? Para ello es mejor escribir un
"archivo" con terminaci√≥n =.jl= que contenga todo el c√≥digo que queremos ejecutar.

Para "cargar" nuestro c√≥digo dentro de la =repl= podemos utilizar la funci√≥n
=include=, si nuestro archivo =script.jl= incluye lo siguiente:

#+begin_src julia
  x = 3
  y = 4
#+end_src

Podemos leer dichas variables de la siguiente forma:

 #+begin_src julia
   julia> include("script.jl")

   julia> y
   4
 #+end_src

¬øEst√° chulo no? Pero ¬øQu√© pasa si modificamos nuestro c√≥digo? Tendr√≠amos que
ejecutar el =include= de nuevo, lo cual es tedioso cuando lo haces m√∫ltiples
veces, por ello existen paquetes que nos ayudan a aumentar las capacidades de
nuestra =repl=, uno de estos paquetes es =Revise.jl=, para instalarlo debemos de ejecutar en el =repl=:

#+begin_src julia
  using Pkg
  Pkg.add("Revise")
#+end_src

Esto descargar√° el c√≥digo fuente de =Revise= y lo instalar√° para que lo tengamos
disponibles dentro de nuestro sistema.

Una vez instalado s√≥lo tenemos que introducir el comando:

#+begin_src julia
  using Revise
#+end_src

Para que la =repl= est√© pendiente de los cambios que hacemos al archivo de manera
autom√°tica, algo m√°s, si no quieres introducir =using Revise= cada vez que inicias
la =repl= puedes ejecutar este comando para modificar la configuraci√≥n del =repl= de
julia:

#+begin_src bash
  echo "using Revise" >> ~/.julia/config/startup.jl
#+end_src


Otra opci√≥n es utilizar bibilotecas como =Pluto.js= para ejecutar un cuaderno a
trav√©s del navegador (similar a los notebooks de Jupyter), salvo que esta
biblioteca est√° enfocada 100% a Julia. Para utilizar [[https://github.com/fonsp/Pluto.jl][pluto]] corremos los
siguientes comandos en la =repl=:

#+begin_src julia
  using Pkg
  Pkg.add("Pluto")
  import Pluto
  Pluto.run()
#+end_src

Adem√°s tenemos la opci√≥n de correr nuestro c√≥digo en un cuaderno de Jupyter
(como se vio en clase) o utilizar un editor como VSCode para ejecutar el c√≥digo
ah√≠.

En resumen:

- La forma m√°s f√°cil de ejecutar c√≥digo interactivamente es usando =Pluto.jl=.
- Para proyectos grandes que requieran compartir c√≥digo podemos usar =VSCode=.
- Para usados avanzados podemos utilizar =emacs=, =vim= y la =repl=.


** Sint√°xis

Julia es un lenguaje con tipado din√°mico, lo que quiere decir que las variables
pueden "cambiar de forma" seg√∫n la informaci√≥n que est√© almacenada en ellas, una
variable le dice a la computadora la cantidad de espacio que necesita para
almacenar dicha informaci√≥n, los tipos de variables m√°s comunes en Julia son:

- Enteros (=Int64=)
- Reales (=Float64=)
- Booleanos (=Bool=)
- Cadenas de texto (=String=)

Los enteros y los reales se almacenan (por defecto) utilizando 64 bits (de ah√≠
el sufijo), si necesitas cambiar el tama√±o/precisi√≥n puedes optar por las
variantes =Int8= o =Int128=, aunque la mayor parte del tiempo la opci√≥n por defecto
funciona bien.

Para declarar una variable necesitamos un nombre de variable seguido del operador de asignaci√≥n ===, por √∫ltimo necesitamos declarar el valor de la variable:

#+begin_src julia
  nombre = "Julia"
  edad = 9
#+end_src

Para obtener el valor de una variable solamente necesitamos escribir el nombre
que le dimos, si yo escribo =nombre= Julia me regresar√° la cadena ="Julia"= como
respuesta. Para actualizar el valor de una variable existente debemos repetir la
operaci√≥n de asignaci√≥n especificando el nuevo valor (esto sobreescribe
cualquier cosa que estuviera asignada como valor a la variable):

#+begin_src julia
  edad = 19
#+end_src

Ac√° la variable =edad= tiene el valor =19=, a partir de este momento ya no podemos
acceder al valor anterior. Para obtener el tipo de dato asignado a una variable podemos hacer uso de la funci√≥n =typeof=:

#+begin_src julia
  julia> typeof(edad)
  Int64
#+end_src

Julia es un lenguaje "vivo" por lo que nos permite examinarlo y nos puede decir
las cosas que podemos hacer con cada una de las variables que est√°n declaradas
en un programa, para descubrir eso podemos utilizar la funci√≥n =methodswith= que
nos devuelve una lista de operaciones que son compatibles con el tipo de dato
que le pasamos como argumento:

#+begin_src julia
  julia> first(methodswith(Int64), 5)
  [1] AbstractFloat(x::Int64) @ Base float.jl:268
  [2] Float16(x::Int64) @ Base float.jl:159
  [3] Float32(x::Int64) @ Base float.jl:159
  [4] Float64(x::Int64) @ Base float.jl:159
  [5] Int64(x::Union{Bool, Int32, Int64, UInt16, UInt32, UInt64, UInt8, Int128, Int16, Int8, UInt128}) @ Core boot.jl:784
#+end_src

¬øQu√© est√° pasando aqu√≠? ü§î estamos "encadenando" funciones, primero llamamos a
la funci√≥n =methodswith= con el argumento =Int64=, esto nos regresa una lista de m√°s
de 200 elementos (m√°s de los que necesitamos por ahora), para no llenar nuestra
pantalla con jerogl√≠ficos "cortamos" la salida para obtener los primeros 5
elementos de dicha lista, por esa raz√≥n "encadenamos" el resultado anterior con una llamada a la funci√≥n =first= que toma los primeros N elementos de una lista:

#+begin_src julia
  julia> first([9,8,7,6,5,4,3,2,1], 3)
  [9,8,7]
#+end_src


** Tipos de dato definidos por el usuario

Si bien las variables definidas en la bibiloteca est√°ndar de Julia nos sirven
para realizar c√≥mputo de manera general en ocasiones las abstracciones
necesarias para resolver un problema no est√°n declaradas ah√≠, por lo que nos
toca, como programadores definir dichas abstracciones, imaginen que quiero hacer
un programa para sacar estad√≠sticas de TikTok, pero Julia no sabe que es un
tiktok,bueno, nos tocar√° definir el tipo de dato =tiktok= para poder hacer operaciones sobre √©l, para ello utilizamos la palabra reservada =struct=:

#+begin_src julia
  struct Tiktok
      titulo::String
      url::String
      likes::Int64
      favorito::Bool
  end
#+end_src

Para inspeccionar los campos definidos dentro de un =struct= utilizamos la funci√≥n
=fieldnames=:

#+begin_src julia
  julia> fieldnames(Tiktok)
  (:titulo, :url, :likes, :favorito)
#+end_src

Si queremos crear una variable de tipo =Tiktok= necesitamos especificar cada uno
de los atributos que conforman el =struct= (ya que ah√≠ se define lo que
necesitamos para crear un tiktok v√°lido). Cre√©mos 2 variables de este tipo:

#+begin_src julia
  video1 = Tiktok("meme", "https://vm.tiktok.com/ZMhpDU3SE/", 13000, false)
  video2 = Tiktok("gato", "https://vm.tiktok.com/ZMhpDdbar/", 23400, true)
#+end_src

Algo muy importante, *no podemos cambiar* los atributos de un =struct= una vez
declarada una variable ya que es una [[https://en.wikipedia.org/wiki/Persistent_data_structure][estructura de datos inmutable]], si se quiere cambiar la definici√≥n de los atributos de un =struct= se debe de declarar como una estructura tipo =mutable struct=.

** Operaciones booleanas y comparaciones num√©ricas

En Julia tenemos los siguientes operadores booleanos:

- Negacion =!=. Por ejemplo =!true= se eval√∫a a =false=
- Conjunci√≥n =&&=. Por ejemplo =(false && true) || (!false)= se eval√∫a a =true=
- Disyunci√≥n =||=. Por ejemplo =(6 isa Int64) && (6 isa Real)= se eval√∫a a =true=

En cuanto a los operadores aritm√©ticos:

- Igualdad ====. Ejemplo =1 == 1= se eval√∫a a =true=
- Desigualdad =!==. Ejemplo 1 != 2 se eval√∫a a =true=
- Menor qu√© <, menor o igual <=. Ejemplo 1 < 3 se eval√∫a a =true=
- Mayor qu√© >, mayor o igual =>. Ejmeplo 2 > 1 se eval√∫a a =false=

Podemos mezclar distintos tipos de n√∫mero como:

#+begin_src julia
  1 == 2.123
#+end_src

** Funciones

La sint√°xis b√°sica para una funci√≥n es:

#+begin_src julia
  function nombre(argumento1, argumento2, ..., argumentoN)
      cuerpo de la funcion
      return valor_de_retorno
  end
#+end_src

Las funciones inician con la palabra reservada =function= seguido del nombre de la
funci√≥n, dentro de los par√©ntesis se encuentran cada uno de los argumentos que
la funci√≥n necesita separados por comas. Todas las variables que declaremos en
el cuerpo de la funci√≥n son eliminadas despu√©s de que dicha funci√≥n se ejecuta,
si dicha funci√≥n regresa un valor necesitamos declararlo con la palabra
reservada =return=, por √∫ltimo necesitamos declarar el fin del cuerpo de la
funci√≥n con =end=.

Existe una forma compacta de declarar funciones, la siguiente declaraci√≥n es equivalente a la declaraci√≥n anterior:

#+begin_src julia
  nombre(argumento1, ..., argumentoN) = cuerpo_de_la_funcion_en_una_linea
#+end_src

En Julia podemos redefinir funciones para que tomen distintos argumentos a la
declaraci√≥n original de la funci√≥n, esto se conoce como =multiple dispatch=,
cuando tenemos un =struct= y le decimos a Julia que imprima el valor de una
variable de este tipo Julia manda a llamar a la funci√≥n =Base.show= que regresa
una tupla con los valores que tiene la estructura, pues bien, para imprimir algo
distinto podemos declarar una funci√≥n que tambi√©n se llame =Base.show= pero que
imprima nuestro tiktot de manera distinta.

#+begin_src julia
  Base.show(io::IO, t::Tiktok) = print(
      io, t.titulo, " üìπ, ",
      t.url, " üñ•Ô∏è, ",
      t.likes, " ‚ù§Ô∏è, ",
      t.favorito, " üìî"
  )

#+end_src

Despu√©s de definir esta funci√≥n podemos imprimir el valor de la variable =video1=:

#+begin_src julia
  meme üìπ, https://vm.tiktok.com/ZMhpDU3SE/ üñ•Ô∏è, 13000 ‚ù§Ô∏è, false üìî
#+end_src

** Multiples valores de retorno

Una funci√≥n tambi√©n puede regresar m√∫ltiples valores de retorno:

#+begin_src julia
  function suma_multiplica(x, y)
      suma = x + y
      multiplicacion = x * y
      return suma, multiplicacion
  end
#+end_src

En este caso podemos aprovechar estos m√∫ltiples valores de retorno de la siguiente forma:

1. Generar 2 variables para que cada una almacene cada valor de retorno:

#+begin_src julia
  valor1, valor2 = suma_multiplica(2,3)
#+end_src

La variable =valor1= almacenar√≠a =5=, mientras que la variable =valor2= almacenar√≠a =6=.

2. Definir una √∫nica variable que almacenar√° una tupla que contiene los dos
   valores, podemos acceder a cada uno con =first= o =last=:

#+begin_src julia
  valor = suma_multiplica(2,3)
#+end_src

Si ejecutamos =first(valor)= obtenemos =5=, mientras que =last(valor)= nos regresa =6=.

** Argumentos por defecto

Podemos definir una funci√≥n que tome argumentos por defecto, supongamos que
tenemos una funci√≥n para definir el logaritmo y que si el usuario no especifica
la base calcularemos el logaritmo base 2 del argumento:

#+begin_src julia
  function logaritmo(x::Real; base::Real=2.7182818284590)
      return log(base, x)
  end
#+end_src

Si ejecutamos la funci√≥n con un √∫nico argumento =logaritmo(10)= obtenemos algo como =2.30=, sin embargo al querer especificar el argumento opcional debemos de separar los argumentos de la funci√≥n con un punto y coma (=;=) de la siguiente forma:

#+begin_src julia
  logaritmo(10; base=2)
#+end_src

Esto nos regresa =3.32=

** Funciones con signo de admiraci√≥n (!)

Es una convenci√≥n dentro de julia el agregar un signo de admiraci√≥n (=!=) a
aquellas funciones que modificar el valor de sus argumentos, es decir, que las
funciones /no puras/ deben tener esta advertencia, pero ¬øQu√© es una funci√≥n /no
pura/? Son aquellas funciones que tienen [[https://en.wikipedia.org/wiki/Pure_function][efectos secundarios]], es decir, que
despu√©s de la ejecuci√≥n de la funci√≥n el mundo donde esta funci√≥n fue declarada
ya no es lo mismo üò¢, imaginemos una funci√≥n que inserta informaci√≥n en un
excel, esta funci√≥n cada que se ejecuta modifica el excel por lo que determinar
el resultado de la funci√≥n depende de un estado espec√≠fico del libro de excel.

#+begin_src julia
  function suma!(V)
      for i in eachindex(V)
          V[i] += 1
      end
      return nothing
  end
#+end_src

Estas funciones son *dependientes del contexto donde se ejecutan*, un ejemplo de
c√≥mo modifican su mundo es el siguiente:

#+begin_src julia
  arreglo = [1, 2, 3]
  suma!(arreglo)
  arreglo
#+end_src

Esto devuelve =[2, 3, 4]=, siendo que el arreglo original ten√≠a los elementos
=[1,2,3]=

** Funciones an√≥nimas (lambdas)

En ocasiones no nos interesa asociarle un nombre a una funci√≥n ya que s√≥lo nos
interesa el resultado de aplicar dicha funci√≥n (hacemos esto usualmente al
procesar arreglos o un stream de datos), para estos casos necesitamos declarar
una *funci√≥n an√≥nima*, la sint√°xis es simple, se utiliza el operador =->= a la
izquierda se definen los par√°metros que requiere la funci√≥n, mientras que a la
derecha definimos las operaciones que haremos:

#+begin_src julia
  x -> x * x
#+end_src

Podemos aplicar una funci√≥n an√≥nima a todos los elementos de un arreglo de la
siguiente manera:

#+begin_src julia
  map(x -> x * x, [1,2,3,4])
#+end_src

Esto nos regresa un vector con el contenido =1, 4, 9, 16=.

** Condicionales

La estructura general del condicional =if= es:

#+begin_src julia
  a = 1
  b = 2

  if a < b
      "a es menor que b"
  elseif a > b
      "a es mayor que b"
  else
      "a is igual to b"
  end
#+end_src

Gracias a =elsif= podemos agregar m√∫ltiples condiciones dentro de un =if=.

** Ciclos
*** For

La manera t√≠pica de ciclar con Julia es utilizar =for=, este constructo necesita
que especifiques c√≥mo es que Julia ciclar√°, la manera m√°s utilizada es hacer uso
de un "contador" que tomar√° el valor de cada uno de los elementos de la
colecci√≥n sobre la que estamos iterando:

#+begin_src julia
  for i in 1:10
      println(i)
  end
#+end_src

*** While

En Julia, =while= es una mezcla de los condicionales y el ciclo =for=, la diferencia
est√° en que el ciclado depender√° de un enunciado booleano, mientras dicho
enunciado sea correcto el ciclo se repetir√° al infinito:

#+begin_src julia
  n = 0

  while n < 3
      global n += 1
  end

  n
#+end_src

La etiqueta =global= le dice al ciclo =while= que estamos accediendo a una variable
declarada fuera del alcance del bloque de c√≥digo actual.
