* Animando escenas con python

Expresar conceptos matem치ticos a otras personas no es f치cil ya que debes:

+ Entender el concepto.
+ Comunicar de manera efectiva el concepto.
+ Crear un espacio en el que la otra persona pueda visualizar la informaci칩n de
  tal manera que pueda ser entendida de manera efectiva.

Por esta raz칩n presentaremos una herramienta de animaci칩n para la ense침anza de
las matem치ticas, dicha herramienta es una biblioteca de Python llamada =manim=,
esta es la herramienta de visualizaci칩n utilizada por el canal de youtube
llamado [[https://www.youtube.com/@3blue1brown][3blue1brown]] (si no lo conoces, deber칤as). Lo primero que necesitamos
antes de utilizar la herramienta es instalar las dependencias y la herramienta
en s칤, para ello es necesario conocer la [[https://docs.manim.community/en/stable/index.html][p치gina oficial del proyecto]] donde se
encontrar치 toda la documentaci칩n necesaria (as칤 como las instrucciones de
instalaci칩n). Por cuestiones de tiempo s칩lo se pondr치n las instrucciones de
instalaci칩n para sistemas linux (basados en Debian), la instalaci칩n para [[MacOs][macos]] y
[[https://docs.manim.community/en/stable/installation/windows.html][windows]] puede ser seguida desde la [[https://docs.manim.community/en/stable/installation/linux.html][p치gina oficial]].

** Instrucciones de instalaci칩n (Linux)

Lo primero que tenemos que hacer es instalar un par de bibliotecas y la
aplicaci칩n =ffmpeg= que se encargar치 de generar el v칤deo:

#+begin_src bash
  sudo apt update
  sudo apt install build-essential python3-dev libcairo2-dev libpango1.0-dev ffmpeg texlive texlive-latex-extra
#+end_src

Otro requerimento es tener instalado =python3-pip= y =venv= y =pkgconfig=:

#+begin_src bash
  sudo apt install python3-pip python3-venv python3-dev pkg-config
#+end_src

Por 칰ltimo se instala =manim= con:

#+begin_src bash
  pip3 install manim
#+end_src

Esto instala =manim= de manera global, como python es una herramienta que es
utilizada por varios administradores de paquetes (como =Conda=) lo m치s
recomendable es crear un =ambiente virtual= al iniciar con un proyecto nuevo, de
esta manera las dependencias del proyecto son locales al proyecto (es decir, no
se comparten de manera global en toda la computadora) ya que en ocasiones pueden
ocurrir "colisiones" de dependencias donde el proyecto A requiere la version =x=
de una biblioteca mientras que el proyecto B requiere la versi칩n =y= de la misma
biblioteca. Lo mejor de esto es que los ambientes virtuales funcionan en
cualquier sistema operativo.

** Ambientes virtuales en python

Podemos ver un ambiente virtual como una cajita que almacena todos los juguetes
de la sesi칩n de juego, de esta manera podemos mantener organizado nuestro
espacio de trabajo sin los dolores de cabeza que conlleva administrar de manera
general todas las dependencias que los proyectos de python requieren. Para
generar un ambiente virtual basta con ejecutar el siguiente comando:

#+begin_src bash
  mkdir mi_proyecto                # Creamos una carpeta para asociarla al proyecto
  cd mi_proyecto                   # Ingresamos al proyecto
  python3 -m venv .mi_proyecto     # Creamos un ambiente virtual
  source .mi_proyecto/bin/activate # Activamos el amiente virtual
  pip install --upgrade pip        # Refrescamos la versi칩n del administrador de paquetes
  pip install mis_bibliotecas      # Instalamos las dependencias
#+end_src

Para nuestra sesi칩n de animaci칩n crearemos un proyecto llamado =pixar101= de la
siguiente forma:

#+begin_src bash
  mkdir pixar
  cd pixar
  python3 -m venv .pixar
  source .pixar/bin/activate
  pip install --upgrade pip
  pip install manim
#+end_src

** 춰Hola Mundo!

Para comenzar crearemos un archivo llamado =hola_mundo.py= donde vamos a animar
algo muy sencillo, para =manim= una animaci칩n sucede en el contexto de una escena
(como en el cine), las escenas heredan de la clase =Scene=:

#+begin_src python
  class HolaMundo(Scene):
      def construct(self)
      # Ac치 van las instrucciones de la animaci칩n
#+end_src

Recuerden que en python los constructores de las clases se definen a trav칠s de
una funci칩n llamada =construct=, dentro de este constructor podemos hacer uso de
objetos como ejes, seguidores de posici칩n/movimiento, animar puntos, etc.

Para ejecutar nuestra animaci칩n necesitamos correrla con el siguiente comando:

#+begin_src bash
  manim hola_mundo.py
#+end_src

Durante este tutorial estaremos siguiendo los ejemplos m치s sencillos que se
muestran en la [[https://docs.manim.community/en/stable/examples.html][gu칤a oficial de manim]]

*** Calentando motores

La animaci칩n m치s simple que podemos generar es una imagen est치tica (游뗻),
dibujaremos figuras b치sicas como un cuadrado, un tri치ngulo, un c칤rculo y una
letra, agregaremos color a dichas figuras y sobrepondremos las im치genes para
hacerlo m치s interesante.

La primer cosa que tenemos que hacer dentro de nuestro script es importar la
biblioteca de animaci칩n, para ello necesitamos insertar lo siguiente:

#+begin_src python
  from manim import *
#+end_src

Despu칠s es necesario declarar el color de fondo que v치mos a estar utilizando, el
color se define utilizando un formato hexadecimal (los c칩digos de los colores
pueden ser consultados en esta [[https://htmlcolorcodes.com/][p치gina]]), para acceder a la c치mara hacemos
referencia al objeto =self.camera=, dicho objeto tiene hartos atributos y uno de
ellos es =background_color=, entonces para establecer el gris de "fondo" escribimos:

#+begin_src python
  self.background_color = "#ece6e2"
#+end_src

Ahora definiremos un par de colores, los colores son simplemente cadenas de
texto con el sufijo =#=:

#+begin_src python
  verde = "#87c2a5"
  azul  = "#525893"
  rojo  = "#e07a5f"
  negro = "#343434" # Los dise침adores dicen que es "malo" usar el negro puro
#+end_src

Crear figuras es relativamente f치cil, para generar un c칤rculo usamos =Circle=,
para generar un tr칤angulo usamos =Triangle= y para generar un cuadrado usamos
=Square=:

#+begin_src python
  circulo = Circle(color=azul, fill_opacity=1).shift(LEFT)
  cuadrado = Square(color=rojo, fill_opacity=1).shift(UP)
  triangulo = Triangle(color=verde, fill_opacity=1).shift(RIGHT)
#+end_src

쯈u칠 es ese =.shift(ALGO)= que pones al final de declarar cada figura? Bien, por
defecto =manim= dibuja todo lo que le digamos en el centro de la pantalla, para
evitar que todo se vea encimado movemos (=shift=) cada figura hacia arriba (=UP=), a
la derecha (=RIGHT=) o a la izquierda (=LEFT=).

Para dibujar las figuras debemos mandar a llamar al m칠todo =self.add= seguido de
una tupla donde le decimos a =manim= qu칠 es lo que queremos dibujar:

#+begin_src python
  self.add(circulo, cuadrado, triangulo) # El orden de las variables importa!!!
#+end_src

=manim= soporta el uso de LaTeX, probemos agregar texto a nuestra escena:

#+begin_src python
  letra = MathTex(r"\mathbb{J}", fill_color=logo_black).scale(6)
  letra.shift(3 * LEFT + 1.5 * UP)
#+end_src

Para renderizar latex hacemos una llamada a =MathTex= dentro de la llamada podemos
poner cualquier cadena de texto para rederizado, por 칰ltimo escalamos la letra 6
veces (=.scale=), despu칠s de definir la letra la movemos 3 unidades a la izquieda
y 1.5 hacia arriba 쮸lguien identific칩 una transformacion lineal 游뱂?

Despu칠s de definir m칰ltiples elementos es posible agruparlos para "imprimirlos"
de una manera mucho m치s sencilla, para ello mandamos a llamar a la funci칩n
=VGroup=:

#+begin_src python
  todo_junto = VGroup(triangulo, cuadrado, circulo, letra) # El orden importa!!!
  todo_junto.move_to(ORIGIN) # 쯋na traslaci칩n?
  self.add(todo_junto)
#+end_src

Para cerrar dejo el contenido completo del archivo (dibujando la letra):

#+begin_src python
  from manim import *

  class HolaMundo(Scene):
      def construct(self):
          self.camera.background_color = "#ece6e2"

          verde = "#87c2a5"
          azul  = "#525893"
          rojo  = "#e07a5f"
          negro = "#343434" # Los dise침adores dicen que es "malo" usar el negro puro

          circulo = Circle(color=azul, fill_opacity=1).shift(LEFT)
          cuadrado = Square(color=rojo, fill_opacity=1).shift(UP)
          triangulo = Triangle(color=verde, fill_opacity=1).shift(RIGHT)

          letra = MathTex(r"\mathbb{J}", fill_color=logo_black).scale(6)
          letra.shift(3 * LEFT + 1.5 * UP)

          todo_junto = VGroup(triangulo, cuadrado, circulo, letra) # El orden importa!!!
          todo_junto.move_to(ORIGIN) # 쯋na traslaci칩n?
          self.add(todo_junto)

          # Recuerda renderizar esto ejecutando lo siguiente en la l칤nea de comandos:
          # manim hola_mundo.py
#+end_src


** Crear anotaciones

Para dibujar un punto se hace uso del m칠todo =Dot=, para dibujar una l칤nea usamos
=Line=, en ocasiones queremos decorar un elemento que fue declarado con
anterioridad (puede que ese elemento sea el resultado de una transformaci칩n),
uno de los tantos m칠todos para decorar es =set_color=.

#+begin_src python
  from manim import *

  class Anotaciones(Scene):
      def construct(self):
          punto = Dot([-2, -1, 0]) # Creamos un punto en un plano
          punto2 = Dot([2, 1, 0])  # Creamos otro punto

          # Con base en los puntos definidos anteriormente creamos una l칤nea
          linea = Line(punto.get_center(), punto2.get_center()).set_color(ORANGE)

          # Si renderizamos esto obtendr칤amos una l칤nea anaranjada
          #self.add(linea, punto, punto2)

          llave1 = Brace(linea) # Decoramos la l칤nea con una llave
          texto_llave1 = llave1.get_text("Distancia horizontal")

          # Decoramos la l칤nea con otra llave
          # Pero esta vez le decimos que la direcci칩n de la misma ser치 rotada "pi"
          # Y sacamos el vector unitario.
          llave2 = Brace(linea, direction=linea.copy().rotate(PI)).get_unit_vector()
          texto_llave2 = llave2.get_text("Distancia vertical")

          llave3 = Brace(linea, direction=linea.copy().rotate(PI / 2)).get_unit_vector()
          texto_llave3 = llave2.get_text("x - x_1")

          self.add(linea, punto, punto2, llave1, llave2, llave3, texto_llave1, texto_llave2, texto_llave3)
#+end_src

** Dibujando un vector en un plano

Para dibujar un plano hacemos uso del m칠todo =NumberPlane=, mientras que, para
dibujar un vector necesitamos llamar =Arrow=

#+begin_src python
  from manim import *

  class CajaDeVectores(Scene):
      def construct(self):
          punto = Dot(ORIGIN) # Dibujamos un punto en el origen
          # Los vectores pueden son de tres dimensiones
          vector = Arrow(ORIGIN, [2, 2, 0], buff=0) # Dibujamos el vector (2,2, 0)
          plano = NumberPlane() # Dibujamos un plano
          texto_origen = Text('(0, 0)').next_to(dot, DOWN)
          texto_punta_vector = Text('(2, 2)').next_to(arrow.get_end(), RIGHT)
          self.add(plano, punto, vector, texto_origen, texto_punta_vector)
#+end_src

** Generando un gradiente

Podemos generar un objeto animable desde una imagen con =ImageMobject=:

#+begin_src python
  from manim import *

  class Gradiente(Scene):
      def construct(self):
          n = 256 # Queremos n칰meros entre 0 y 255
          arreglo = np.uint8(
              [[i * 256 / n for i in range(0, n)] for _ in range(0, n)]
          )
          # arreglo.shape # => (256, 256)
          imagen = ImageMobject(arreglo).scale(2)
          imagen.background_rectangle = SurroundingRectangle(imagen, GREEN)
          self.add(imagen, imagen.background_rectangle)
#+end_src

** Animaciones

Las animaciones hacen uso de la funci칩n =play=, como en el Power Point podemos
"animar" las transiciones con la funci칩n =FadeIn= para que se vea "bonito".

#+begin_src python
  from manim import *

  class BooleanOperations(Scene):
      def construct(self):
          ellipse1 = Ellipse(
              width=4.0, height=5.0, fill_opacity=0.5, color=BLUE, stroke_width=10
          ).move_to(LEFT)
          ellipse2 = ellipse1.copy().set_color(color=RED).move_to(RIGHT)
          bool_ops_text = MarkupText("<u>Operaciones Booleanas</u>").next_to(ellipse1, UP * 3)
          ellipse_group = Group(bool_ops_text, ellipse1, ellipse2).move_to(LEFT * 3)
          self.play(FadeIn(ellipse_group))

          i = Intersection(ellipse1, ellipse2, color=GREEN, fill_opacity=0.5)
          self.play(i.animate.scale(0.25).move_to(RIGHT * 5 + UP * 2.5))
          intersection_text = Text("Intersecci칩n", font_size=23).next_to(i, UP)
          self.play(FadeIn(intersection_text))

          u = Union(ellipse1, ellipse2, color=ORANGE, fill_opacity=0.5)
          union_text = Text("Uni칩n", font_size=23)
          self.play(u.animate.scale(0.3).next_to(i, DOWN, buff=union_text.height * 3))
          union_text.next_to(u, UP)
          self.play(FadeIn(union_text))

          e = Exclusion(ellipse1, ellipse2, color=YELLOW, fill_opacity=0.5)
          exclusion_text = Text("Diferencia Sim칠trica", font_size=23)
          self.play(e.animate.scale(0.3).next_to(u, DOWN, buff=exclusion_text.height * 3.5))
          exclusion_text.next_to(e, UP)
          self.play(FadeIn(exclusion_text))

          d = Difference(ellipse1, ellipse2, color=PINK, fill_opacity=0.5)
          difference_text = Text("Diferencia", font_size=23)
          self.play(d.animate.scale(0.3).next_to(u, LEFT, buff=difference_text.height * 3.5))
          difference_text.next_to(d, UP)
          self.play(FadeIn(difference_text))
#+end_src


** Usando una figura como gu칤a para una animaci칩n

Podemos utilizar referencias geom칠tricas para aplicar m치s animaciones, como
ejemplo est치n las funciones =GrowFromCenter=, =Transform=, =MoveAlongPath= y =Rotating=.

#+begin_src python
  from manim import *

  class PointMovingOnShapes(Scene):
      def construct(self):
          circle = Circle(radius=1, color=BLUE)
          dot = Dot()
          dot2 = dot.copy().shift(RIGHT)
          self.add(dot)

          line = Line([3, 0, 0], [5, 0, 0])
          self.add(line)

          self.play(GrowFromCenter(circle))
          self.play(Transform(dot, dot2))
          self.play(MoveAlongPath(dot, circle), run_time=2, rate_func=linear)
          self.play(Rotating(dot, about_point=[2, 0, 0]), run_time=1.5)
          self.wait()
#+end_src

** Ejercicio

쮺칩mo har칤as la siguiente animaci칩n?

[[file+sys:ejercicio1.mp4][Video]]
